단일 연결리스트(이동 단순, ++) : 저장단위 == 노드

[head]									[tail]
[10][] -> [20][] -> [30][] -> [40][] -> [50][] -||(NULL)

[30][] > 노드(node) : 데이터 저장소, Link(다음번 노드 주소) 저장소

예) 저장소: 책상, 데이터: 학생

배열 : 강의실에 미리 책생을 배치, 학생은 강의실ㄹ에 들어와서 첫번째 책상부터 순차적으로 착석
	   나갈 때는 학생만 나간다.(뒤에 앉은 학생은 이동)
	   오버플로우(강의실에 책상이 40개 있으면 학생 40명까지 입실)

연결리스트: 강의실이 비어있음. 학생은 책상을 들고 들어와서 아무데나 놓는ㄴ다. 그리고 착석(다음으로 들어온 학생만 기억)
			학생이 책상 들고나간다.(한사람만 논리적 순서 정리)
			강의실이 허용하는 한 계속 입실 가능

배열과 연결리스트 시작점

배열 
- int arr[10]; // 미리 공간을 생성

연결리스트
- 노드 정의(구조체): Node [30][]

Node* head = NULL;		// 첫번재 노드의 주소를 저장하는 포인터

연결리스트 push_front
1) 노드 생성 및 초기화

2) 연결과정 (비어있는 상황 VS 노드가 존재하는 상황)
   ** 새로운 노드를 먼저 연결 ** 

연결리스트 push_back : 꼬리노드를 찾아야한다!!


연결리스트 printall :  주소를 기반으로한 순회
1) 순회할 수 있는 포인터 : 첫번째 노드의 주소를 저장
	cur = head;
2) 이동
	cur = cur->next;

삭제 
- pop_front (첫번째)
(1) 노드가 여러개인 경우
1) 삭제할 노드의 주소를 저장
2) 삭제할 노드를 연결에서 제외
del = head;
head = head->next
3) del 노드를 힙 메모리에서 제거

(2) 노드가 한 개인 경우 -> 동일하게 연산된다.
del = head;
head = head->next

- pop_back (마지막)
(1) 노드가 여러개인 경우
1) 삭제할 노드의 주소를 저장
2) 전 노드를 찾아야함 pre
3) 삭제할 노드를 연결에서 제외 -> 전 노드의 링크가 NULL이 되어야함.
4) del 노드를 힙 메모리에서 제거

(2) 노드가 한 개인 경우 -> 다르게 처리
head = NULL;
